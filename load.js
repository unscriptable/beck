/** @license MIT License (c) copyright B Cavalier & J Hann */

/* DO NOT EDIT THIS FILE.  IT IS GENERATED FROM THE src/ FOLDER. */

(function (global/*, XMLHttpRequest, globalEval*/) {

	/***** temporary loader impl *****/

	var modules, shimImpl;

	modules = {};

	shimImpl = function (/* parentImpl, options */) {
		return {
			global: global,
			strict: true,
			cache: modules,

			evalAsync: getShimAndCall('evalAsync'),
			"import": getShimAndCall('import'),
			load: function (idOrArray, callback, errback) {
				var loader = this;
				if (typeof idOrArray != 'string' || !isBeckModule(idOrArray)) {
					getShim(function (newImpl) {
						return newImpl.load(idOrArray, callback, errback);
					});
				}
				else {
					fetchModule(idOrArray, callback, errback);
				}
			},

			eval: failNotReady,
			get: before(function (id) { return modules[id]; }, failIfNotBeckModule),
			has: function (id) { return id in modules; },
			set: before(function (id, value) { return modules[id] = value; }, failIfNotBeckModule),
			"delete": before(function (id) { delete modules[id]; }, failIfNotBeckModule)
		};
	};

	function failIfNotBeckModule (id) {
		if (!isBeckModule(id)) failNotReady();
	}

	function isBeckModule (id) {
		return id.slice(0, 4) == 'beck';
	}

	/**
	 * Creates a function that will call the ES6 Loader shim when it becomes
	 * available and then call back.  This is used to implement async methods
	 * on the ES6 Loader stub.
	 * @private
	 * @param {String} funcName
	 * @return {Function}
	 */
	function getShimAndCall (funcName) {
		return function callImplAsync () {
			var args = arguments;
			getShim(function (newImpl) {
				newImpl[funcName].apply(newImpl, args);
			});
		};
	}

	/**
	 * Creates a function that will call the ES6 Loader shim sync or fail
	 * if the shim isn't available, yet.
	 * @private
	 * @param {String} funcName
	 * @return {Function}
	 */
	function implCaller (funcName) {
		return function () {
			return getImpl(this)[funcName].apply(this, arguments);
		};
	}

	/**
	 * Shim ES6 Loader.
	 * @constructor
	 * @param options
	 * @param options
	 * @private
	 */
	function Loader (parent, options) {
		var impl, vo;
		impl = new shimImpl(parent, options);
		setImpl(this, impl);
	}

	Loader.prototype = {
		// TODO: use Object.defineProperties or a sham for it
		global: global,
		strict: true,
		evalAsync: function (src, callback, errback) {
			getImpl(this).evalAsync(src, callback, errback);
		},
		"import": function (idOrArray, callback, errback) {
			getImpl(this)['import'](idOrArray, callback, errback);
		},
		load: function (idOrArray, callback, errback) {
			getImpl(this).load(idOrArray, callback, errback);
		},
		eval: function (src) { return getImpl(this).eval(src); },
		get: function (name) { return getImpl(this).get(name); },
		set: function (name, value) { return getImpl(this).set(name, value); },
		has: function (name) { return getImpl(this).has(name); },
		"delete": function (name) { return getImpl(this)['delete'](name); }
	};

	// sniff System and Loader
	if (typeof global.Loader == 'undefined') {
		global.Loader = Loader;
	}

	if (typeof global.System == 'undefined') {
		global.System = new Loader();
	}

	if (typeof global.Module == 'undefined') {
		// TODO: implement the Module constructor
		global.Module = function Module (obj) { return obj; };
		global.ToModule = function ToModule (obj) { return new Module(obj); };
	}


	/***** stuff to load a real ES6 Loader shim *****/

	var getShim, saveShim, shim;

	/**
	 * Gets the shim and calls back.  Uses before advice to modify the getShim
	 * function to instruct any further calls to just queue callbacks.
	 * @function
	 * @param {Function} cb
	 */
	getShim = before(
		function (cb) {
			fetchShim(saveShim);
		},
		function (cb) {
			// rewrite getShim
			getShim = waitForShim;
			// register the first callback as a waiter
			waitForShim(cb);
		}
	);

	/**
	 * Saves the shim implementation.  Uses after advice to modify the getShim
	 * function to stop queueing callbacks and calls them immediately, instead.
	 * All callbacks are called at this point.
	 * @function
	 */
	saveShim = after(
		swapShimImpl,
		function (impl) {
			// rewrite getShim
			getShim = callShimNow;
			callShimWaiters(impl);
		}
	);

	shim = {
		impl: null,
		waiters: []
	};

	/**
	 * Fetches the Loader shim module and its dependencies.
	 * @private
	 * @param {Function} callback
	 */
	function fetchShim (callback) {
		var ids, count, id, LoaderImpl;

		ids = [
			'promise',
			'object',
			'path',
			'Pipeline',
			'fetchText'
		];
		count = ids.length;

		System.load('beck/LoaderImpl', after(setLoader, countdown));
		while (id = ids.shift()) {
			System.load('beck/' + id, countdown);
		}

		function countdown () {
			if (count-- == 0) callback(LoaderImpl);
		}

		function setLoader (impl) {
			LoaderImpl = impl;
		}
	}

	function waitForShim (callback) {
		shim.waiters.push(callback);
	}

	function callShimWaiters (impl) {
		var waiter;
		while (waiter = shim.waiters.shift()) waiter(impl);
		delete shim.waiters;
	}

	function swapShimImpl (Impl) {
		// save the implementation for calls to `new Loader()`
		shimImpl = Impl;
		// switch System loader's impl and transfer cache, options, etc.
		var oldImpl = getImpl(System),
			newImpl = new Impl(oldImpl, oldImpl.options);
		setImpl(System, newImpl);
		// return a usable new implementation
		return newImpl;
	}

	function callShimNow (cb) { cb(shim.impl); }

	var implKey = {};

	function setImpl (loader, impl) {
		var vo;
		vo = loader.valueOf;
		loader.valueOf = function () {
			if (arguments[0] == implKey) return impl;
			else return vo.apply(loader);
		};
	}

	function getImpl (loader) {
		return loader.valueOf(implKey);
	}

	function failNotReady () {
		throw new Error('Cannot access loader before it is fully loaded.');
	}


	/***** simple, temporary AMD for loading local modules *****/

	/**
	 * Simple module-ish fetcher.
	 * @param {String} id
	 * @param {Function} callback
	 * @param {Function} [errback]
	 */
	function fetchModule (id, callback, errback) {
		var url;
		if (System.has(id)) callback(System.get(id));
		else {
			url = addBaseUrl(baseUrl, ensureExt(id));
			loadScript(
				{ id: id, url: url },
				function success () {
					if (!System.has(id)) {
						fail(new Error('Module not found. Probably a syntax error (or a 404 in IE).'));
					}
					else {
						callback(System.get(id));
					}
				},
				fail
			);
		}
		function fail (ex) {
			ex = ex || new Error('Could not load');
			ex.message += ' ' + url;
			if (errback) errback(ex); else throw ex;
		}
	}

	/**
	 * Constructs a module definition context. Allows us to use `instanceof`
	 * to positively identify a module that hasn't had its factory run, yet.
	 * @private
	 * @param factory
	 * @param ex
	 * @constructor
	 */
	function Mctx (factory, ex) {
		this.factory = factory;
		if (ex) this.ex = ex;
	}


	/***** script loader *****/

	var doc, loadScript, baseUrl, activeScripts, getDefinedModuleId;

	doc = global.document;

	// node, ringojs, etc.
	if (typeof module != 'undefined' && typeof require == 'function') {
		baseUrl = '../';
		loadScript = createCallbackLoader(require);
		// in node, module.id is bogus, don't try to use it.
		getDefinedModuleId = noop;
	}
	// browser
	else if (doc) {
		activeScripts = {};
		baseUrl = stripFilePart(findScriptPath()) + '../';
		loadScript = createBrowserScriptLoader(doc);
		getDefinedModuleId = getCurrentScriptId;
	}
	// fail
	else {
		loadScript = function () {
			throw new Error('Can\'t load scripts in this environment.');
		};
	}

	function createCallbackLoader (loadFunc) {
		return function (options, cb, eb) {
			var url = options.url;
			try { cb(loadFunc(url)); } catch (ex) { eb(ex); }
		};
	}

	function createBrowserScriptLoader (doc) {
		var readyStates, head, insertBeforeEl;
		readyStates = 'addEventListener' in global
			? {}
			: { 'loaded': 1, 'complete': 1 };
		head = doc && (doc['head'] || doc.getElementsByTagName('head')[0]);
		// to keep IE from crying, we need to put scripts before any
		// <base> elements, but after any <meta>. This usually works.
		insertBeforeEl = head && head.getElementsByTagName('base')[0] || null;
		return function (options, cb, eb) {
			var el;
			el = doc.createElement('script');
			el.async = true;
			el.src = options.url;
			el.onload = el.onreadystatechange = process;
			el.onerror = fail;
			// loading will start when the script is inserted into the dom.
			// IE will load the script sync if it's in the cache, so
			// indicate the current resource definition first.
			activeScripts[options.id] = el;
			return head.insertBefore(el, insertBeforeEl);

			// initial script processing
			function process (ev) {
				ev = ev || global.event;
				// detect when it's done loading
				// ev.type == 'load' is for all browsers except IE6-9
				// IE6-9 need to use onreadystatechange and look for
				// el.readyState in {loaded, complete} (yes, we need both)
				if (ev.type == 'load' || readyStates[el.readyState]) {
					delete activeScripts[options.id];
					el.onload = el.onreadystatechange = el.onerror = '';
					cb();
				}
			}

			function fail () {
				eb(new Error('Syntax or http error.'));
			}
		};
	}

	function findScriptPath () {
		var scriptDataAttr, scriptMatchRx, scripts, current, script, path;
		scriptDataAttr = 'data-beck-load';
		scriptMatchRx = /beck.*js/;
		current = doc.currentScript;
		if (!current) {
			scripts = [];
			scripts.push.apply(scripts, doc.scripts || doc.getElementsByTagName('script'));
			while (!current && (script = scripts.pop())) {
				if (script.readyState == 'interactive') current = script;
				else if (script.hasAttribute(scriptDataAttr)) current = script;
				else if (scriptMatchRx.test(script.src)) current = script;
			}
		}
		if (current) path = current.src;
		return path;
	}

	function getCurrentScriptId () {
		// IE6-9 mark the currently executing thread as "interactive"
		// Note: Opera lies about which scripts are "interactive", so we
		// just have to test for it. Opera provides a true browser test, not
		// a UA sniff, thankfully.
		if (!typeof global['opera'] == 'Opera') {
			// learned this technique from James Burke's RequireJS
			for (var id in activeScripts) {
				if (activeScripts[id].readyState == 'interactive') {
					return id;
				}
			}
		}
	}


	/***** AOP *****/

	function before (func, advice) {
		return function () {
			advice.apply(null, arguments);
			return func.apply(this, arguments);
		}
	}

	function after (func, advice) {
		return function () {
			var result = func.apply(this, arguments);
			advice(result);
			return result;
		}
	}

	/***** other stuff *****/

	var absUrlRx = /^\/|^[^:]+:\/\//;

	function stripFilePart (path) {
		return path && path.slice(0, path.lastIndexOf('/') + 1);
	}

	function joinPath (p1, p2) {
		return p1 + (p1.substr(p1.length - 1) == '/' ? '' : '/') + p2;
	}

	function ensureExt (path) {
		return path.indexOf('.js') == path.length - 3 ? path : path + '.js';
	}

	function addBaseUrl (baseUrl, path) {
		return absUrlRx.test(path) ? path : joinPath(baseUrl, path);
	}

	function noop () {}

}(
	typeof global == 'object' ? global : this.window || this.global || {}
));(function (scopedRequire) {

	var slice, fetchText, fs;

	slice = Array.prototype.slice;

	// determine the correct method upon first use
	fetchText = function (url, callback, errback) {
		if (hasXhr()) {
			fetchText = xhrFetch;
		}
		else if (hasFsModule()) {
			fetchText = isNodeFs() ? nodeFetch : cjsFetch;
		}
		else {
			fetchText = failFetch;
		}
		return fetchText(url, callback, errback);
	};

	System.set('beck/fetchText', new Module(fetch));

	function fetch (url, callback, errback) {
		return fetchText(url, callback, errback);
	}

	function xhrFetch (url, callback, errback) {
		var xhr;
		xhr = new XMLHttpRequest();
		xhr.open('GET', url, true);
		xhr.onreadystatechange = function () {
			if (xhr.readyState === 4) {
				if (xhr.status < 400) {
					callback(xhr.responseText);
				}
				else {
					errback(new Error('fetchText() failed. status: ' + xhr.status + ' - ' + xhr.statusText));
				}
			}
		};
		xhr.send(null);
	}

	function nodeFetch (url, callback, errback) {
		fs.readFile(url, function (err) {
			if (err) {
				errback(err);
			}
			else {
				callback.apply(this, slice.call(arguments, 1));
			}
		});
	}

	function cjsFetch (url, callback, errback) {
		try {
			callback(fs.read(url));
		}
		catch (ex) {
			errback(ex);
		}
	}

	function failFetch () {
		throw new Error('Could not create a text file fetcher.');
	}

	function hasXhr () {
		return typeof XMLHttpRequest != 'undefined';
	}

	function hasFsModule () {
		if (scopedRequire) {
			try {
				fs = scopedRequire('fs');
				return true;
			}
			catch (ex) { }
		}
	}

	function isNodeFs () {
		return typeof fs.readFile == 'function' && fs.readFile.length > 1;
	}

}(typeof require == 'function' && require));(function () {

	var object = {
		create: Object.create || create,
		extend: Object.extend || extend
	};

	System.set('beck/object', new Module(object));

	function create (base) {
		Begetter.prototype = base || null;
		var o = new Begetter();
		Begetter.prototype = null;
		return o;
	}

	function extend (base, props) {
		var o = create(base);
		for (var p in props || {}) {
			if (props.hasOwnProperty(p)) o[p] = props[p];
		}
		return o;
	}

	function Begetter () {}

}());(function () {
var path, absUrlRx, findDotsRx;

absUrlRx = /^\/|^[^:]+:\/\//;
findDotsRx = /(\.)(\.?)(?:$|\/([^\.\/]+.*)?)/g;

/**
 * @type {Object}
 * @module 'beck/path'
 */
path = {
	/**
	 * Returns true if the url is absolute (not relative to the document)
	 * @param {String} url
	 * @return {Boolean}
	 */
	isAbsUrl: function (url) { return absUrlRx.test(url); },

	isRelPath: function (url) { return url.charAt(0) == '.'; },

	joinPaths: function (base, sub) {
		base = path.removeEndSlash(base);
		return (base ? base + '/' : '') + sub;
	},

	removeEndSlash: function (path) {
		return path && path.charAt(path.length - 1) == '/'
			? path.substr(0, path.length - 1)
			: path;
	},

	ensureExt: function (path, ext) {
		return path.lastIndexOf(ext) == path.length - ext.length
			? path
			: path + ext;
	},

	reduceLeadingDots: function (childId, baseId) {
		var removeLevels, normId, levels, isRelative, diff;
		// this algorithm is similar to dojo's compactPath, which
		// interprets module ids of "." and ".." as meaning "grab the
		// module whose name is the same as my folder or parent folder".
		// These special module ids are not included in the AMD spec
		// but seem to work in node.js, too.

		removeLevels = 1;
		normId = childId;

		// remove leading dots and count levels
		if (path.isRelPath(normId)) {
			isRelative = true;
			// replaceDots also counts levels
			normId = normId.replace(findDotsRx, replaceDots);
		}

		if (isRelative) {
			levels = baseId.split('/');
			diff = levels.length - removeLevels;
			if (diff < 0) {
				// this is an attempt to navigate above parent module.
				// maybe dev wants a url or something. punt and return url;
				return childId;
			}
			levels.splice(diff, removeLevels);
			// normId || [] prevents concat from adding extra "/" when
			// normId is reduced to a blank string
			return levels.concat(normId || []).join('/');
		}
		else {
			return normId;
		}

		function replaceDots (m, dot, dblDot, remainder) {
			if (dblDot) removeLevels++;
			return remainder || '';
		}
	}
};

System.set('beck/path', new Module(path));

}());/***** deferred *****/
(function (global) {

	/**
	 * promise implementation adapted from https://github.com/briancavalier/avow
	 * @return {Deferred}
	 * @constructor
	 */
	function Deferred () {
		var dfd, promise, pendingHandlers, bindHandlers;

		promise = { then: then, yield: yieldVal };

		// Create a dfd, which has a pending promise plus methods
		// for fulfilling and rejecting the promise
		dfd = this;

		/**
		 * Provides access to the deferred's promise, which has .then() and
		 * .yield() methods.
		 * @type {Object}
		 */
		this.promise = promise;

		/**
		 * Fulfills a deferred, resolving its promise.
		 * @param value
		 */
		this.fulfill = function (value) {
			applyAllPending(applyFulfill, value);
		};
		/**
		 * Rejects a deferred, rejecting its promise.
		 * @param reason
		 */
		this.reject = function (reason) {
			applyAllPending(applyReject, reason);
		};

		// Queue of pending handlers, added via then()
		pendingHandlers = [];

		// Arranges for handlers to be called on the eventual value or reason
		bindHandlers = function (onFulfilled, onRejected, vow) {
			pendingHandlers.push(function (apply, value) {
				apply(value, onFulfilled, onRejected, vow.fulfill, vow.reject);
			});
		};

		return dfd;

		// Arrange for a handler to be called on the eventual value or reason
		function then (onFulfilled, onRejected) {
			var dfd = new Deferred();
			bindHandlers(onFulfilled, onRejected, dfd);
			return dfd.promise;
		}

		// When the promise is fulfilled or rejected, call all pending handlers
		function applyAllPending (apply, value) {
			var bindings;

			// Already fulfilled or rejected, ignore silently
			if (!pendingHandlers) return;

			bindings = pendingHandlers;
			pendingHandlers = undefined;

			// The promise is no longer pending, so we can swap bindHandlers
			// to something more direct
			bindHandlers = function (onFulfilled, onRejected, vow) {
				nextTurn(function () {
					apply(value, onFulfilled, onRejected, vow.fulfill, vow.reject);
				});
			};

			// Call all the pending handlers
			nextTurn(function () {
				var binding;
				while (binding = bindings.pop()) binding(apply, value);
			});
		}

		function yieldVal (val) {
			return promise.then(function () { return val; });
		}
	}

	// Call fulfilled handler and forward to the next promise in the queue
	function applyFulfill (val, onFulfilled, _, fulfillNext, rejectNext) {
		apply(val, onFulfilled, fulfillNext, fulfillNext, rejectNext);
	}

	// Call rejected handler and forward to the next promise in the queue
	function applyReject (val, _, onRejected, fulfillNext, rejectNext) {
		apply(val, onRejected, rejectNext, fulfillNext, rejectNext);
	}

	// Call a handler with value, and take the appropriate action
	// on the next promise in the queue
	function apply (val, handler, fallback, fulfillNext, rejectNext) {
		var result;
		try {
			if (typeof handler != 'function') return fallback(val);
			result = handler(val);
			if (isThenable(result)) result.then(fulfillNext, rejectNext);
			else fulfillNext(result);
		}
		catch (e) {
			rejectNext(e);
		}
	}

	function isDeferred (it) {
		return it && it instanceof Deferred;
	}

	function isThenable (it) {
		return it && typeof it.then == 'function';
	}

	function when (it, callback, errback) {
		var dfd;
		if (!isThenable(it)) {
			dfd = new Deferred();
			dfd.fulfill(it);
			it = dfd.promise;
		}
		return it.then(callback, errback);
	}

	function all (things) {
		var howMany, dfd, results, thing;

		howMany = 0;
		dfd = new Deferred();
		results = [];

		while (thing = things[howMany]) when(thing, counter(howMany++), dfd.reject);

		if (howMany == 0) dfd.fulfill(results);

		return dfd.promise;

		function counter (i) {
			return function (value) {
				results[i] = value;
				if (--howMany == 0) dfd.fulfill(results);
			};
		}
	}

	// Use process.nextTick or setImmediate if available, fallback to setTimeout
	var nextTurn = function () {
		nextTurn = typeof global.setImmediate == 'function'
			? global.setImmediate.bind(global)
			: typeof process === 'object'
				? process.nextTick
				: function (task) { setTimeout(task, 0); };
		return nextTurn.apply(this, arguments);
	};

	var promise = {
		defer: function () { return new Deferred(); },
		isDeferred: isDeferred,
		isThenable: isThenable,
		when: when,
		all: all,
		nextTurn: nextTurn
	};

	System.set('beck/promise', new Module(promise));

}(typeof global == 'object' ? global : this.window || this.global || {}));
(function (global, cjsmEval, globalEval) {


	/***** imports *****/

	var path = System.get('beck/path');
	var reduceLeadingDots = path.reduceLeadingDots;
	var joinPaths = path.joinPaths;
	var ensureExt = path.ensureExt;
	var fetchText = System.get('beck/fetchText');


	/***** exports *****/

	function Pipeline () {
		return {
			normalize: normalize,
			resolve: resolve,
			fetch: fetch,
			translate: translate,
			link: link
		};
	}

	System.set('beck/Pipeline', new Module(Pipeline));

	var removeCommentsRx, findRValueRequiresRx, absUrlRx;

	removeCommentsRx = /\/\*[\s\S]*?\*\/|\/\/.*?[\n\r]/g;
	findRValueRequiresRx = /require\s*\(\s*(["'])(.*?[^\\])\1\s*\)|[^\\]?(["'])/g;
	absUrlRx = /^\/|^[^:]+:\/\//;

	function normalize (name, referer) {
		var normalized, mctx;
		if (typeof referer == 'object') referer = referer.name;
		normalized = reduceLeadingDots(String(name), referer || '');
		mctx = {
			name: normalized,
			relName: name,
			refererName: referer
		};
		return {
			normalized: normalized,
			metadata: mctx
		};
	}

	function resolve (normalized, options) {
		var mctx = options.metadata;
		mctx.url = ensureExt(joinPaths('./', normalized), '.js');
		return mctx.url;
	}

	function fetch (resolved, fulfill, reject, options) {
		fetchText(
			resolved,
			function (source) {
				fulfill(addSourceUrl(resolved, source));
			},
			reject
		);
	}

	function translate (source, options) {
		return source;
	}

	function link (source, options) {
		if (options.type == 'script') {
			return parseScript(source, options);
		}
		else {
			return parseCjsm(source, options);
		}
	}

	function isAbsUrl (url) {
		return absUrlRx.test(url);
	}

	function addSourceUrl (url, source) {
		return source
			+ '\n/*\n////@ sourceURL='
			+ url.replace(/\s/g, '%20')
			+ '\n*/\n';
	}

	function parseScript (source, options) {
		return void globalEval(source);
	}

	function parseCjsm (source, options) {
		var mctx, currQuote, clean;

		mctx = options.metadata;
		mctx.deps = [];
		mctx.depsMap = {};

		// remove comments, then look for require() or quotes
		clean = source.replace(removeCommentsRx, '');
		clean.replace(findRValueRequiresRx, function (m, rq, id, qq) {
			// if we encounter a string in the source, don't look for require()
			if (qq) {
				currQuote = currQuote == qq ? void 0 : currQuote;
			}
			// if we're not inside a quoted string
			else if (!currQuote) {
				// push [relative] id into deps list and deps map
				if (!(id in mctx.depsMap)) {
					mctx.depsMap[id] = mctx.deps.push(id) - 1;
				}
			}
			return ''; // uses least RAM/CPU
		});

		return {
			imports: mctx.deps,
			execute: createCjsmFactory(source, options)
		};
	}

	// Note: does not support computed module ids in require() calls or
	// async require(id, cb, eb) as in AMD!
	function createCjsmFactory (source, options) {
		// just create a factory
		return function () {
			var mctx, deps, require, exports, module, glob;

			mctx = options.metadata;
			deps = arguments;
			require = function (id) {
				var dep;
				if (id in mctx.depsMap) {
					dep = deps[mctx.depsMap[id]];
				}
				// TODO: figure out if/how to resolve relative require()s of dynamic modules
				else if (isAbsUrl(id) && System.has(id)) {
					dep = System.get(id);
				}
				else {
					throw new Error('Module not resolved: ' + id + '. Dynamic require() not supported.');
				}
				return dep;
			};
			exports = {};
			module = { id: mctx.name, uri: mctx.url, exports: exports };
			glob = ('global' in options && options.global)
				|| ('global' in mctx && mctx.global)
				|| global;

			cjsmEval(require, exports, module, glob, source);

			return module.exports;
		};
	}

}(
	typeof global != 'undefined' ? global : this.global || this.window,
	function (require, exports, module, global) { eval(arguments[4]); },
	function () { (1, eval)(arguments[0]); }
));(function (global, globalEval) {

	var promise = System.get('beck/promise');
	var when = promise.when;
	var defer = promise.defer;
	var all = promise.all;
	var Pipeline = System.get('beck/Pipeline');
	var extend = System.get('beck/object').extend;

	function LoaderImpl (parentImpl, options) {
		var pipeline;
		if (!options) options = {};
		// inherit from parent
		this.cache = parentImpl ? extend(parentImpl.cache) : {};
		this.pipeline = pipeline = parentImpl && parentImpl.pipeline
			? extend(parentImpl.pipeline)
			: new Pipeline();
		// extend from options
		if ('global' in options) this.global = options.global;
		if ('strict' in options) this.strict = options.strict;
		if ('normalize' in options) pipeline.normalize = options.normalize;
		if ('resolve' in options) pipeline.resolve = options.resolve;
		if ('fetch' in options) pipeline.fetch = options.fetch;
		if ('translate' in options) pipeline.translate = options.translate;
		if ('link' in options) pipeline.link = options.link;
	}

	LoaderImpl.prototype = {

		global: global,
		strict: true,

		"eval": function (source) {
			return globalEval(source, this.global);
		},

		evalAsync: function (source, callback, errback) {
			if (!callback) callback = noop;
			if (!errback) errback = fail;
			try {
				callback(this.eval(source));
			}
			catch (ex) {
				if (arguments.length > 1) errback(ex); else throw ex;
			}
		},

		load: function (ids, callback, errback, options) {
			if (!errback) errback = fail; // propagate by default
			return this.fulfillAsType(ids, 'script', options)
				.then(spread(callback), errback);
		},

		"import": function (ids, callback, errback, options) {
			if (!errback) errback = fail; // propagate by default
			return this.fulfillAsType(ids, 'module', options)
				.then(spread(callback), errback);
		},

		get: function (name) {
			var module;
			module = this.cache[String(name)];
			// note: when all things in the cache are instanceof Module,
			// this sniff will be safer
			if (module && typeof module.execute == 'function') {
				// run factory
				var deps = [];
				for (var i = 0; i < module.imports.length; i++) {
					deps[i] = this.get(module.imports[i]);
				}
				this.cache[String(name)] = module
					= module.execute.apply(null, deps);
			}
			return module;
		},

		has: function (name) {
			return String(name) in this.cache;
		},

		set: function (name, thing) {
			this.cache[String(name)] = new Module(thing);
		},

		"delete": function (name) {
			delete this.cache[String(name)];
		},

		fulfillAsType: function (ids, type, options) {
			var referer, pipelineOptions, promises, i;

			if (Object.prototype.toString.call(ids) != '[object Array]') {
				ids = [ids];
			}

			referer = { type: type };

			if (options) {
				referer.name = options.module || null;
				referer.address = options.address || null;
			}
			pipelineOptions = { type: type, referer: referer };

			promises = [];

			for (i = 0; i < ids.length; i++) {
				promises.push(this.runPipeline(ids[i], pipelineOptions));
			}
			return all(promises);
		},

		runPipeline: function (id, options) {
			var pipeline, loader, withOptions, promisify;

			// TODO: conflate callbacks onto a single next-turn
			// TODO: pre-prepare pipeline instead of building it from scratch each time
				// withOptions
				// promisify

			pipeline = this.pipeline;
			loader = this;
			withOptions = this.withOptions;
			promisify = this.promisify;

			// start pipeline with id as input
			return when(id)

			// normalize name
			.then(pipeline.normalize)

			// process result according to spec
			.then(withOptions(bind(this, 'processNormalized'), options))

			// abort if we've already got this module or we're fetching it
			.then(withOptions(bind(this, 'checkCache'), options))

			// resolve url
			.then(withOptions(pipeline.resolve, options))

			// process result according to spec
			.then(withOptions(bind(this, 'processResolved'), options))

			// fetch from url
			.then(withOptions(promisify(pipeline.fetch), options))

			// translate to javascript
			.then(withOptions(pipeline.translate, options))

			// link
			.then(withOptions(pipeline.link, options))

			// get imported modules
			.then(withOptions(bind(this, 'processImports'), options))

			// process result according to spec
			.then(withOptions(bind(this, 'processModule'), options))

			// callback or handle errors and early aborts
			.then(null, function (reason) {
				if (reason instanceof Module) {
					return loader.get(options.normalized);
				}
				else if (promise.isDeferred(reason)) {
					return reason;
				}
				else {
					throw reason;
				}
			});
		},

		processNormalized: function (result, options) {
			if (typeof result == 'object') {
				options.normalized = result.normalized;
				options.metadata = result.metadata;
			}
			else {
				options.normalized = result;
			}
			options.referer = null;
			return options.normalized;
		},

		processResolved: function (result, options) {
			if (typeof result == 'object') {
				options.address = result.address;
				if ('extra' in result) options.extra = result.extra;
			}
			else {
				options.address = result;
			}
			return options.address;
		},

		processImports: function (result, options) {
			var imports, count, promises;
			// scripts don't return a result
			imports = result ? result.imports : [];
			count = 0;
			promises = [];
			while (count < imports.length) {
				promises.push(this.load(imports[count]));
				count++;
			}
			return all(promises).yield(result);
		},

		processModule: function (module, options) {
			// TODO: handle when result is undefined? (per spec)
			if (!module instanceof Module) module = new Module(module);
			var dfd = this.get(options.normalized);
			this.set(options.normalized, module);
			// hackish way to ensure factory has run
			module = this.get(options.normalized);
			if (promise.isDeferred(dfd)) dfd.fulfill(module);
			return module;
		},

		checkCache: function (normalized, options) {
			if (this.has(normalized)) {
				// throw it so we can abort the rest of the pipeline.
				// it'll get caught in the error handler.
				throw new this.get(normalized);
			}
			else {
				// put a promise in the cache
				// can't use .set() here since it'll turn the promise into a module
				this.cache[normalized] = defer();
			}
			return normalized;
		},

		withOptions: function (func, options) {
			return function () {
				var args = toArray(arguments);
				args.push(options);
				return func.apply(this, args);
			};
		},

		promisify: function (func) {
				// assumes that the returned function expects
				// 2nd and 3rd params to be callbacks and inserts them.
				return function () {
					var dfd, args, result;
					dfd = defer();
					args = toArray(arguments);
					args.splice(1, 0, dfd.fulfill, dfd.reject);
					try {
						result = func.apply(this, args);
					}
					catch (ex) {
						dfd.reject(ex);
					}
					return dfd.promise;
				};
			}

	};

	System.set('beck/LoaderImpl', new Module(LoaderImpl));

	function toArray (obj) {
		return Array.prototype.slice.apply(obj);
	}

	function bind (ctx, funcName) {
		return function () {
			return ctx[funcName].apply(ctx, arguments);
		}
	}

	function spread (func) {
		return function (params) {
			return func.apply(null, params);
		};
	}

	function noop () {}

	function fail (ex) { throw ex; }

}(
	typeof global == 'object' ? global : this.window || this.global || {},
	function () { return (1, eval).call(arguments[1], arguments[0]); }
));